import apiHelper from '../utils/apiHelper';

export interface ThingSpeakChannel {
  id: string;
  patientId: string;
  patientName: string;
  channelId: string;
  status: 'active' | 'inactive' | 'error';
  lastUpdate: Date | null;
  currentValues: {
    [key: string]: number;
  };
  surgeryType?: string;
  apiKeys: {
    read: string;
    write: string;
  };
  dataPoints: number;
}

export interface SystemHealth {
  apiStatus: 'online' | 'offline';
  responseTime: number;
  uptime: number;
  totalChannels: number;
  activeChannels: number;
  inactiveChannels: number;
  errorChannels: number;
  dataPointsToday: number;
  bandwidth: number;
}

export interface CriticalAlert {
  id: string;
  patientId: string;
  patientName: string;
  type: 'high_bp' | 'low_bp' | 'irregular_heartbeat' | 'low_oxygen' | 'high_temp' | 'fall_detected' | 'device_offline' | 'battery_low';
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  value?: number;
  normalRange?: string;
  timestamp: Date;
  acknowledged: boolean;
  acknowledgedBy?: string;
  acknowledgedAt?: Date;
  resolved: boolean;
  resolvedBy?: string;
  resolvedAt?: Date;
  notes?: string;
  location?: string;
  autoGenerated: boolean;
}

export interface DashboardData {
  channels: {
    list: ThingSpeakChannel[];
    summary: {
      total: number;
      active: number;
      inactive: number;
      error: number;
    };
  };
  systemHealth: SystemHealth;
  alerts: {
    list: CriticalAlert[];
    summary: {
      total: number;
      critical: number;
      high: number;
      medium: number;
      low: number;
      unacknowledged: number;
    };
  };
  lastUpdated: string;
}

/**
 * ThingSpeak Service
 * Provides methods to interact with ThingSpeak API endpoints
 */
class ThingSpeakService {
  private baseUrl = '/api/thingspeak';

  /**
   * Get all patient channels with their status
   */
  async getAllChannels(): Promise<{ channels: ThingSpeakChannel[]; summary: any }> {
    try {
      const response = await apiHelper.get(`${this.baseUrl}/channels`);
      return response.data;
    } catch (error) {
      console.error('Error fetching channels:', error);
      throw new Error('Failed to fetch ThingSpeak channels');
    }
  }

  /**
   * Get system health metrics
   */
  async getSystemHealth(): Promise<SystemHealth> {
    try {
      const response = await apiHelper.get(`${this.baseUrl}/system-health`);
      return response.data;
    } catch (error) {
      console.error('Error fetching system health:', error);
      throw new Error('Failed to fetch system health data');
    }
  }

  /**
   * Get critical alerts
   */
  async getCriticalAlerts(filters?: {
    severity?: string;
    type?: string;
    acknowledged?: boolean;
  }): Promise<{ alerts: CriticalAlert[]; summary: any }> {
    try {
      const params = new URLSearchParams();
      if (filters?.severity) params.append('severity', filters.severity);
      if (filters?.type) params.append('type', filters.type);
      if (filters?.acknowledged !== undefined) {
        params.append('acknowledged', filters.acknowledged.toString());
      }

      const url = params.toString() 
        ? `${this.baseUrl}/alerts?${params.toString()}`
        : `${this.baseUrl}/alerts`;
      
      const response = await apiHelper.get(url);
      return response.data;
    } catch (error) {
      console.error('Error fetching alerts:', error);
      throw new Error('Failed to fetch critical alerts');
    }
  }

  /**
   * Get specific channel details
   */
  async getChannelDetails(channelId: string, results: number = 10): Promise<any> {
    try {
      const response = await apiHelper.get(
        `${this.baseUrl}/channel/${channelId}?results=${results}`
      );
      return response.data;
    } catch (error) {
      console.error('Error fetching channel details:', error);
      throw new Error('Failed to fetch channel details');
    }
  }

  /**
   * Update patient's ThingSpeak channel mapping
   */
  async updatePatientChannel(
    patientId: string,
    channelData: {
      channelId: string;
      readApiKey: string;
      writeApiKey?: string;
    }
  ): Promise<any> {
    try {
      const response = await apiHelper.post(
        `${this.baseUrl}/patient/${patientId}/channel`,
        channelData
      );
      return response.data;
    } catch (error) {
      console.error('Error updating patient channel:', error);
      throw new Error('Failed to update patient channel mapping');
    }
  }

  /**
   * Remove patient's ThingSpeak channel mapping
   */
  async removePatientChannel(patientId: string): Promise<any> {
    try {
      const response = await apiHelper.delete(
        `${this.baseUrl}/patient/${patientId}/channel`
      );
      return response.data;
    } catch (error) {
      console.error('Error removing patient channel:', error);
      throw new Error('Failed to remove patient channel mapping');
    }
  }

  /**
   * Get comprehensive dashboard data (optimized single call)
   */
  async getDashboardData(): Promise<DashboardData> {
    try {
      const response = await apiHelper.get(`${this.baseUrl}/dashboard-data`);
      
      // Convert timestamp strings to Date objects
      const data = response.data as DashboardData;
      
      // Convert channel lastUpdate strings to Date objects
      data.channels.list = data.channels.list.map(channel => ({
        ...channel,
        lastUpdate: channel.lastUpdate ? new Date(channel.lastUpdate) : null
      }));
      
      // Convert alert timestamps to Date objects
      data.alerts.list = data.alerts.list.map(alert => ({
        ...alert,
        timestamp: new Date(alert.timestamp),
        acknowledgedAt: alert.acknowledgedAt ? new Date(alert.acknowledgedAt) : undefined,
        resolvedAt: alert.resolvedAt ? new Date(alert.resolvedAt) : undefined
      }));
      
      return data;
    } catch (error) {
      console.error('Error fetching dashboard data:', error);
      throw new Error('Failed to fetch ThingSpeak dashboard data');
    }
  }

  /**
   * Format time difference for display
   */
  formatTimeAgo(timestamp: Date | null): string {
    if (!timestamp) return 'Unknown';
    
    const now = new Date();
    const diffMs = now.getTime() - timestamp.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins} min ago`;
    if (diffHours < 24) return `${diffHours} hr ago`;
    return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
  }

  /**
   * Get status color for Material-UI components
   */
  getStatusColor(status: string): 'success' | 'warning' | 'error' | 'info' {
    switch (status) {
      case 'active':
      case 'online':
        return 'success';
      case 'inactive':
      case 'degraded':
        return 'warning';
      case 'error':
      case 'offline':
        return 'error';
      default:
        return 'info';
    }
  }

  /**
   * Get severity color for alerts
   */
  getSeverityColor(severity: string): 'success' | 'warning' | 'error' | 'info' {
    switch (severity) {
      case 'critical':
      case 'high':
        return 'error';
      case 'medium':
        return 'warning';
      case 'low':
        return 'info';
      default:
        return 'info';
    }
  }
}

// Export singleton instance
export const thingSpeakService = new ThingSpeakService();
export default thingSpeakService;