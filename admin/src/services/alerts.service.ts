import apiHelper from 'src/utils/apiHelper';

// TypeScript interfaces for Alert data
export interface CriticalAlert {
  id: string;
  patientId: string;
  patientName: string;
  type: 'high_bp' | 'low_bp' | 'irregular_heartbeat' | 'low_oxygen' | 'high_temp' | 'fall_detected' | 'device_offline' | 'battery_low' | 'heart_rate_high' | 'heart_rate_low' | 'blood_pressure_high' | 'fever' | 'oxygen_low';
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  message: string;
  value?: number | string;
  normalRange?: {
    min?: number;
    max?: number | string;
    unit?: string;
  };
  timestamp: Date;
  acknowledged: boolean;
  acknowledgedBy?: string;
  acknowledgedAt?: Date;
  resolved: boolean;
  resolvedBy?: string;
  resolvedAt?: Date;
  notes?: string;
  location?: string;
  autoGenerated: boolean;
  details?: {
    vitals?: {
      value: number | string;
      normalRange: any;
    };
    patientInfo?: {
      name: string;
      patientId: string;
      age?: number;
    };
  };
}

export interface AlertSummary {
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  unacknowledged: number;
}

export interface AlertsResponse {
  alerts: CriticalAlert[];
  summary: AlertSummary;
}

class AlertsService {
  private baseUrl = '/thingspeak';

  /**
   * Get critical alerts with optional filtering
   */
  async getCriticalAlerts(params?: {
    severity?: string;
    type?: string;
    acknowledged?: boolean;
    limit?: number;
  }): Promise<AlertsResponse | null> {
    try {
      const queryParams = new URLSearchParams();
      
      if (params?.severity) queryParams.append('severity', params.severity);
      if (params?.type) queryParams.append('type', params.type);
      if (params?.acknowledged !== undefined) queryParams.append('acknowledged', String(params.acknowledged));
      if (params?.limit) queryParams.append('limit', String(params.limit));
      
      const url = `${this.baseUrl}/alerts${queryParams.toString() ? `?${queryParams.toString()}` : ''}`;
      const response = await apiHelper.get(url);
      
      if (response.success && response.data) {
        const data = response.data;
        
        // Transform dates
        if (data.alerts) {
          data.alerts = data.alerts.map((alert: any) => ({
            ...alert,
            timestamp: new Date(alert.timestamp),
            acknowledgedAt: alert.acknowledgedAt ? new Date(alert.acknowledgedAt) : undefined,
            resolvedAt: alert.resolvedAt ? new Date(alert.resolvedAt) : undefined,
          }));
        }
        
        return data;
      }
      
      return null;
    } catch (error) {
      console.error('Error fetching critical alerts:', error);
      return null;
    }
  }

  /**
   * Get all alerts (including from Alert model)
   */
  async getAllAlerts(params?: {
    status?: 'pending' | 'acknowledged' | 'resolved';
    severity?: string;
    limit?: number;
    skip?: number;
  }): Promise<CriticalAlert[]> {
    try {
      // Use the /alert/active endpoint which returns all active alerts for admin
      const response = await apiHelper.get('/alert/active');
      
      if (response.alerts) {
        // Flatten the grouped alerts structure
        const allAlerts = [
          ...response.alerts.critical,
          ...response.alerts.high,
          ...response.alerts.medium,
          ...response.alerts.low
        ];
        
        // Filter based on parameters
        let filteredAlerts = allAlerts;
        if (params?.status) {
          filteredAlerts = filteredAlerts.filter(alert => alert.status === params.status);
        }
        if (params?.severity) {
          filteredAlerts = filteredAlerts.filter(alert => alert.severity === params.severity);
        }
        if (params?.limit) {
          filteredAlerts = filteredAlerts.slice(0, params.limit);
        }
        
        return filteredAlerts.map((alert: any) => ({
          id: alert._id,
          patientId: alert.userId?.patientId || 'Unknown',
          patientName: alert.userId?.name || 'Unknown Patient',
          type: alert.type,
          severity: alert.severity,
          title: alert.title,
          message: alert.message,
          timestamp: new Date(alert.createdAt),
          acknowledged: alert.status === 'acknowledged' || alert.status === 'resolved',
          resolved: alert.status === 'resolved',
          location: 'Home', // Default location
          autoGenerated: alert.source === 'thingspeak_mock',
          details: alert.details,
          value: alert.details?.vitals?.value,
          normalRange: alert.details?.vitals?.normalRange
        }));
      }
      
      return [];
    } catch (error) {
      console.error('Error fetching all alerts:', error);
      return [];
    }
  }

  /**
   * Acknowledge an alert
   */
  async acknowledgeAlert(alertId: string, notes?: string): Promise<boolean> {
    try {
      const response = await apiHelper.put(`/alert/${alertId}/acknowledge`, {
        notes
      });
      
      return !!response.message;
    } catch (error) {
      console.error('Error acknowledging alert:', error);
      return false;
    }
  }

  /**
   * Resolve an alert
   */
  async resolveAlert(alertId: string, notes?: string): Promise<boolean> {
    try {
      const response = await apiHelper.put(`/alert/${alertId}/resolve`, {
        notes
      });
      
      return !!response.message;
    } catch (error) {
      console.error('Error resolving alert:', error);
      return false;
    }
  }

  /**
   * Create a manual alert
   */
  async createAlert(alertData: {
    patientId: string;
    type: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    title: string;
    message: string;
    details?: any;
  }): Promise<boolean> {
    try {
      const response = await apiHelper.post('/alert/create', alertData);
      
      return !!response.message;
    } catch (error) {
      console.error('Error creating alert:', error);
      return false;
    }
  }

  /**
   * Get alert statistics
   */
  async getAlertStatistics(timeframe?: '24h' | '7d' | '30d'): Promise<any> {
    try {
      const url = `/alert/statistics${timeframe ? `?timeframe=${timeframe}` : ''}`;
      const response = await apiHelper.get(url);
      
      if (response.statistics) {
        return response;
      }
      
      return null;
    } catch (error) {
      console.error('Error fetching alert statistics:', error);
      return null;
    }
  }
}

// Export singleton instance
export const alertsService = new AlertsService();
export default alertsService;